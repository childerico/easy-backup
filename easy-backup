#!/bin/bash

#    easy-backup -- A rsync wrapper to easily perform backups of a set of directories.
#    Copyright (C) 2016 Gabriele Russo Russo
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Terminate execution whenever accessing an unset variable
set -o nounset

# Options to be provided to rsync
RSYNC_OPT='-aShR --delete'




# Adds trailing slash to given path (if missing) and writes it to output.
# Param: $1 -> path
#
_add_trailing_slash()
{
	local path="$1"
	[[ ! ${path} =~ /$ ]] && echo "${path}/" || echo ${path}
}

# Performs backup of given directory using rsync.
# Param: $1 -> source directory
# Param: $2 -> destination directory
#
backup_directory()
{
	local src="$1"
	local dst="$2"

	echo "Syncing: ${src}"
	rsync ${RSYNC_OPT} ${src} ${dst}

	if [[ $? -ne 0 ]]; then
		echo "Failed backup of: ${src_path}!"
		exit 2
	fi
}

# Checks that given directory path is a valid source directory path.
# We require an absolute path.
# 
# Param: $1 -> path
#
check_source_path()
{
	# Check that path is absolute
	if [[ ! "${src:0:1}" == "/" && ! "${src:0:1}" == '~' ]]; then
		echo "Given source path is not an absolute path: ${src} (skipped)" >&2
		return 1
	fi

	# Check that path is a directory
	if [[ ! -d ${src} ]]; then
		echo "Given source is not a directory: ${src} (skipped)" >&2
		return 2
	fi

	return 0
}


# Performs backup of all specified source directories.
# Param: $1 -> file containing source directories (absolute paths)
# Param: $2 -> backup destination directory
#
backup_all_sources()
{
	local src_file="${1}"
	local dst="${2}"
	local retval=1

	cat ${src_file} | while read src_line;
	do
		# Check that line is a valid directory path
		if check_source_path ${src_line}; then
			# Add trailing slash to the path if needed
			local src_path=$(_add_trailing_slash ${src_line})

			backup_directory ${src_path} ${dst}
			retval=0
		fi
	done

	return ${retval} # 0 if backup succeded for at least one directory
}

# Checks if given destination directory is suitable for performing backup.
# We check if backup destination directory exists. If it does not, we try to
# create it. 
# We also check that script has write permissions on that directory.
#
# Param: $1 -> destination directory path
#
check_destination()
{
	local dst=${1}

	# Checks for directory existence
	if [[ ! -d ${dst} ]]; then
		echo "Creating destination directory: ${dst}"
		if  ! mkdir -p ${dst}; then
			echo "[ERROR] Could not create destination directory!" >&2
			return 1
		fi
	fi

	# Checks for write permissions 
	if [[ ! -w ${dst} ]]; then
		echo "[ERROR] You have not write permissions on destination directory!" >&2
		return 1
	fi

	return 0
}

# Prints usage line.
# Param: $1 -> script name
#
_usage()
{
	local progname="$1"
	echo "Usage: ${progname} -s <sources file> -d <destination directory>"
}

# Prints brief usage information.
# Param: $1 -> script name
#
usage()
{
	local progname="$1"

	_usage ${progname}
	echo "Use -h for requesting full help."
}

# Prints help.
# Param: $1 -> script name
# 
help()
{
	local progname="$1"	
	_usage ${progname}
	
	printf "where\n\t"
	printf "<source directories file> contains a list "
	printf "of directory paths to be used\n\t\tas sources for backup, one per line. "
	printf "Absolute path are recommended.\n\t"

	printf "<destination directory path> is the path of directory into which"
	printf " backup will be performed.\n\t\tIn this directory, entire directory "
	printf "hierarchy will be recreated.\n"
}


main()
{
	local src_file=''
	local destination=''

	# Parses CLI options
	while getopts ":s:d:h" opt; do
		case $opt in
			h)
				help $(basename "$0")
				exit 0
				;;
			s)
				src_file="${OPTARG}"
				;;
			d)
				destination="${OPTARG}"
				;;
			\?)
				echo "Invalid option: -$OPTARG" >&2
				usage $(basename "$0")
				exit 1
				;;
			:)
				echo "Option -$OPTARG requires an argument." >&2
				usage $(basename "$0")
				exit 1
				;;
		esac
	done

	# Check that a sources file and a destination directory have been provided
	if [[ "x$src_file" == "x" || "x$destination" == "x" ]]; then
		usage $(basename "$0")
		exit 1
	fi

	# Check that a valid destination directory has been specified
	if ! check_destination ${destination}; then
		exit 3
	fi

	backup_all_sources ${src_file} ${destination}
	exit $?
}

main "${@}"
