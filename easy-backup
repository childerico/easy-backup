#!/bin/bash

#    easy-backup -- A rsync wrapper to easily perform backups of a set of directories.
#    Copyright (C) 2016 Gabriele Russo Russo
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Terminate execution whenever accessing an unset variable
set -o nounset


# Adds trailing slash to given path (if missing) and writes it to output.
# Param: $1 -> path
#
add_trailing_slash()
{
	local path="$1"
	[[ ! ${path} =~ /$ ]] && echo "${path}/" || echo ${path}
}

# Performs backup of given directory using rsync.
# Param: $1 -> source directory
# Param: $2 -> destination directory
# Param: $3 -> file containing excluded patterns
# Param: $4 -> username to use for remote backup
# Param: $5 -> (optional) hostname to use for remote backup
#
backup_directory()
{
	local src="$1"
	local dst="$2"
	local user="${4}"
	local host="${5:-}"
	local RSYNC_OPT='-aShR --delete'

	# Sets option for providing an excluded patterns file
	local exclude_from_opt=""
	[[ $# -gt 2 && ${3} != '/dev/null' ]] && exclude_from_opt="--exclude-from ${3}"

	# Sets SSH related options (if needed)
	local ssh_opt=""
	local host_prefix=""
	if [[ "x${host}" != "x" ]]; then
		ssh_opt='-e ssh'
		[[ ${user} == ${USER} ]] && host_prefix="${host}:" || host_prefix="${user}@${host}:"
	fi

	echo "Syncing: ${src}"
	rsync ${RSYNC_OPT} ${ssh_opt} ${exclude_from_opt} ${src} ${host_prefix}${dst}

	if [[ $? -ne 0 ]]; then
		echo "Failed backup of: ${src_path}"
		exit 2
	fi
}

# Checks that given directory path is a valid source directory path.
# We require an absolute path.
# 
# Param: $1 -> path
#
check_source_path()
{
	local src="$1"

	# Check that path is absolute
	if [[ ! "${src:0:1}" == "/" && ! "${src:0:1}" == '~' ]]; then
		echo "Given source path is not an absolute path: ${src} (skipped)" >&2
		return 1
	fi

	# Check that path is a directory
	if [[ ! -d ${src} ]]; then
		echo "Given source is not a directory: ${src} (skipped)" >&2
		return 2
	fi

	return 0
}


# Performs backup of all specified source directories.
# Param: $1 -> file containing source directories (absolute paths)
# Param: $2 -> backup destination directory
# Param: $3 -> file containing patterns to be excluded
# Param: $4 -> username to use for remote backup
# Param: $5 -> (optional) hostname to use for remote backup
#
backup_all_sources()
{
	local src_file="${1}"
	local dst="${2}"
	local excluded_patterns_file="${3}"
	local user="${4}"
	local host="${5:-}"
	local retval=1

	cat ${src_file} | while read src_line;
	do
		# Check that line is a valid directory path
		if check_source_path ${src_line}; then
			# Add trailing slash to the path if needed
			local src_path=$(add_trailing_slash ${src_line})

			backup_directory ${src_path} ${dst} ${excluded_patterns_file} ${user} ${host}
			retval=0
		fi
	done

	return ${retval} # 0 if backup succeded for at least one directory
}

# Checks if given destination directory is suitable for performing backup.
# We check if backup destination directory exists. If it does not, we try to
# create it. 
# We also check that script has write permissions on that directory.
#
# Param: $1 -> destination directory path
#
check_destination()
{
	local dst=${1}

	# Checks for directory existence
	if [[ ! -d ${dst} ]]; then
		echo "Creating destination directory: ${dst}"
		if  ! mkdir -p ${dst}; then
			echo "[ERROR] Could not create destination directory!" >&2
			return 1
		fi
	fi

	# Checks for write permissions 
	if [[ ! -w ${dst} ]]; then
		echo "[ERROR] You have not write permissions on destination directory!" >&2
		return 1
	fi

	return 0
}

# Prints usage line.
# Param: $1 -> script name
#
_usage()
{
	local progname="$1"
	echo "Usage: ${progname} -s <sources file> -d <destination directory> [-e <excluded patterns file>]"
}

# Prints brief usage information.
# Param: $1 -> script name
#
usage()
{
	local progname="$1"

	_usage ${progname}
	echo "Use -h for requesting full help."
}

# Prints help.
# Param: $1 -> script name
# 
help()
{
	local progname="$1"	
	_usage ${progname}

	cat << EOS

A simple 'rsync' wrapper script for performing an incremental backup of a set of 
directories to a specified location (e.g. an external storage device).

The list of directories to be included in backup is provided through a "sources"
file. The destination for backup is specified as an argument. In this
destination directory, the entire directory hierarchy for selected folders is
created.

PARAMETERS:
-s <source directories file> = file containing the list of directories to be
				included in backup. Absolute paths are required,
				one per line.
				
-d <destination directory>   = directory for storing backup

-e <excluded patterns file>  = (optional) file containing a list of patterns to
                               be excluded from backup (e.g. '*/.git/*')

EXAMPLE:
Assuming that 'backup_directories.txt' is a regular file containing these lines:

	/home/user/music/
	/home/user/pictures/

following command will perform a backup of these directories to '/mnt/external/':
	
	$ easy-backup -s backup_directories.txt -d /mnt/external

The resulting directory hierarchy under '/mnt/external':

	/mnt/external/
		|---- home/
		          |--- user/
			         |--- music/
				        |---- ...
				        |---- ...
			         |--- pictures/
				        |---- ...
				        |---- ...
EOS
}


main()
{
	local src_file=''
	local exclude_file=''
	local destination=''
	local remote_host=''
	local remote_user=''

	# Parses CLI options
	while getopts ":s:r:u:e:d:h" opt; do
		case $opt in
			h)
				help $(basename "$0")
				exit 0
				;;
			s)
				src_file="${OPTARG}"
				;;
			d)
				destination="${OPTARG}"
				;;
			e)
				exclude_file="${OPTARG}"
				;;
			r)
				remote_host="${OPTARG}"
				;;
			u)
				remote_user="${OPTARG}"
				;;
			\?)
				echo "Invalid option: -$OPTARG" >&2
				usage $(basename "$0")
				exit 1
				;;
			:)
				echo "Option -$OPTARG requires an argument." >&2
				usage $(basename "$0")
				exit 1
				;;
		esac
	done

	# Check that a sources file and a destination directory have been provided
	if [[ "x$src_file" == "x" || "x$destination" == "x" ]]; then
		usage $(basename "$0")
		exit 1
	fi

	# Check that a valid destination directory has been specified.
	# (We do NOT perform this check in case of remote backup)
	#
	if [[ "x$remote_host" == "x" ]] && ! check_destination ${destination}; then
		exit 3
	fi

	# Check that excluded patterns file (if specified) exists
	if [[ "x$exclude_file" != "x" && ! -f $exclude_file ]]; then
		usage $(basename "$0")
		exit 4
	fi

	backup_all_sources ${src_file} ${destination} ${exclude_file:-/dev/null} ${remote_user:-$USER} ${remote_host}
	exit $?
}

main "${@}"
